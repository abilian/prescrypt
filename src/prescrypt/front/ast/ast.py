"""AUTOGENERATED FILE! DO NOT EDIT!

Custom AST.
"""

from __future__ import annotations

import ast as _ast
from typing import Any

from .mixin import Mixin

NodeVisitor = _ast.NodeVisitor
NodeTransformer = _ast.NodeTransformer
dump = _ast.dump
unparse = _ast.unparse

ellipsis = type(...)


class AST(_ast.AST, Mixin):
    pass


class mod(_ast.mod, AST):
    pass


class stmt(_ast.stmt, AST):
    pass


class expr(_ast.expr, AST):
    pass


class expr_context(_ast.expr_context, AST):
    pass


class boolop(_ast.boolop, AST):
    pass


class operator(_ast.operator, AST):
    pass


class unaryop(_ast.unaryop, AST):
    pass


class cmpop(_ast.cmpop, AST):
    pass


class comprehension(_ast.comprehension, AST):
    target: expr
    iter: expr
    ifs: list[expr]
    is_async: int


class excepthandler(_ast.excepthandler, AST):
    pass


class arguments(_ast.arguments, AST):
    posonlyargs: list[arg]
    args: list[arg]
    vararg: None | arg
    kwonlyargs: list[arg]
    kw_defaults: list[None] | list[expr]
    kwarg: None | arg
    defaults: list[expr]


class arg(_ast.arg, AST):
    arg: str
    annotation: None | expr
    type_comment: None


class keyword(_ast.keyword, AST):
    arg: None | str
    value: expr


class alias(_ast.alias, AST):
    name: str
    asname: None | str


class withitem(_ast.withitem, AST):
    context_expr: expr
    optional_vars: None | expr


class match_case(_ast.match_case, AST):
    pattern: pattern
    guard: None
    body: list[stmt]


class pattern(_ast.pattern, AST):
    pass


class type_ignore(_ast.type_ignore, AST):
    pass


class slice(_ast.slice, AST):
    pass


class Module(_ast.Module, mod, AST):
    body: list[stmt]
    type_ignores: Any


class FunctionDef(_ast.FunctionDef, stmt, AST):
    name: str
    args: arguments
    body: list[stmt]
    decorator_list: list[expr]
    returns: None | expr
    type_comment: None


class AsyncFunctionDef(_ast.AsyncFunctionDef, stmt, AST):
    name: str
    args: arguments
    body: list[stmt]
    decorator_list: list[expr]
    returns: None | expr
    type_comment: None


class ClassDef(_ast.ClassDef, stmt, AST):
    name: str
    bases: list[expr]
    keywords: list[keyword]
    body: list[stmt]
    decorator_list: list[expr]


class Return(_ast.Return, stmt, AST):
    value: None | expr


class Delete(_ast.Delete, stmt, AST):
    targets: list[expr]


class Assign(_ast.Assign, stmt, AST):
    targets: list[expr]
    value: expr
    type_comment: None


class AugAssign(_ast.AugAssign, stmt, AST):
    target: expr
    op: operator
    value: expr


class AnnAssign(_ast.AnnAssign, stmt, AST):
    target: expr
    annotation: expr
    value: None | expr
    simple: int


class For(_ast.For, stmt, AST):
    target: expr
    iter: expr
    body: list[stmt]
    orelse: list[stmt]
    type_comment: None


class AsyncFor(_ast.AsyncFor, stmt, AST):
    target: expr
    iter: expr
    body: list[stmt]
    orelse: list[stmt]
    type_comment: None


class While(_ast.While, stmt, AST):
    test: expr
    body: list[stmt]
    orelse: list[stmt]


class If(_ast.If, stmt, AST):
    test: expr
    body: list[stmt]
    orelse: list[stmt]


class With(_ast.With, stmt, AST):
    items: list[withitem]
    body: list[stmt]
    type_comment: None


class AsyncWith(_ast.AsyncWith, stmt, AST):
    items: list[withitem]
    body: list[stmt]
    type_comment: None


class Match(_ast.Match, stmt, AST):
    subject: expr
    cases: list[match_case]


class Raise(_ast.Raise, stmt, AST):
    exc: None | expr
    cause: None | expr


class Try(_ast.Try, stmt, AST):
    body: list[stmt]
    handlers: list[excepthandler]
    orelse: list[stmt]
    finalbody: list[stmt]


class Assert(_ast.Assert, stmt, AST):
    test: expr
    msg: None | expr


class Import(_ast.Import, stmt, AST):
    names: list[alias]


class ImportFrom(_ast.ImportFrom, stmt, AST):
    module: None | str
    names: list[alias]
    level: int


class Global(_ast.Global, stmt, AST):
    names: list[str]


class Nonlocal(_ast.Nonlocal, stmt, AST):
    names: list[str]


class Expr(_ast.Expr, stmt, AST):
    value: expr


class Pass(_ast.Pass, stmt, AST):
    pass


class Break(_ast.Break, stmt, AST):
    pass


class Continue(_ast.Continue, stmt, AST):
    pass


class BoolOp(_ast.BoolOp, expr, AST):
    op: boolop
    values: list[expr]


class NamedExpr(_ast.NamedExpr, expr, AST):
    target: expr
    value: expr


class BinOp(_ast.BinOp, expr, AST):
    left: expr
    op: operator
    right: expr


class UnaryOp(_ast.UnaryOp, expr, AST):
    op: unaryop
    operand: expr


class Lambda(_ast.Lambda, expr, AST):
    args: arguments
    body: expr


class IfExp(_ast.IfExp, expr, AST):
    test: expr
    body: expr
    orelse: expr


class Dict(_ast.Dict, expr, AST):
    keys: list[None] | list[expr]
    values: list[expr]


class Set(_ast.Set, expr, AST):
    elts: list[expr]


class ListComp(_ast.ListComp, expr, AST):
    elt: expr
    generators: list[comprehension]


class SetComp(_ast.SetComp, expr, AST):
    elt: expr
    generators: list[comprehension]


class DictComp(_ast.DictComp, expr, AST):
    key: expr
    value: expr
    generators: list[comprehension]


class GeneratorExp(_ast.GeneratorExp, expr, AST):
    elt: expr
    generators: list[comprehension]


class Await(_ast.Await, expr, AST):
    value: expr


class Yield(_ast.Yield, expr, AST):
    value: None | expr


class YieldFrom(_ast.YieldFrom, expr, AST):
    value: expr


class Compare(_ast.Compare, expr, AST):
    left: expr
    ops: list[cmpop]
    comparators: list[expr]


class Call(_ast.Call, expr, AST):
    func: expr
    args: list[expr]
    keywords: list[keyword]


class FormattedValue(_ast.FormattedValue, expr, AST):
    value: expr
    conversion: int
    format_spec: None | expr


class JoinedStr(_ast.JoinedStr, expr, AST):
    values: list[expr]


class Constant(_ast.Constant, expr, AST):
    value: None | bytes | complex | ellipsis | float | int | str
    kind: None | str


class Attribute(_ast.Attribute, expr, AST):
    value: expr
    attr: str
    ctx: expr_context


class Subscript(_ast.Subscript, expr, AST):
    value: expr
    slice: expr
    ctx: expr_context


class Starred(_ast.Starred, expr, AST):
    value: expr
    ctx: expr_context


class Name(_ast.Name, expr, AST):
    id: str
    ctx: expr_context


class List(_ast.List, expr, AST):
    elts: list[expr]
    ctx: expr_context


class Tuple(_ast.Tuple, expr, AST):
    elts: list[expr]
    ctx: expr_context


class Slice(_ast.Slice, expr, AST):
    lower: None | expr
    upper: None | expr
    step: None | expr


class Load(_ast.Load, expr_context, AST):
    pass


class Store(_ast.Store, expr_context, AST):
    pass


class Del(_ast.Del, expr_context, AST):
    pass


class And(_ast.And, boolop, AST):
    pass


class Or(_ast.Or, boolop, AST):
    pass


class Add(_ast.Add, operator, AST):
    pass


class Sub(_ast.Sub, operator, AST):
    pass


class Mult(_ast.Mult, operator, AST):
    pass


class MatMult(_ast.MatMult, operator, AST):
    pass


class Div(_ast.Div, operator, AST):
    pass


class Mod(_ast.Mod, operator, AST):
    pass


class Pow(_ast.Pow, operator, AST):
    pass


class LShift(_ast.LShift, operator, AST):
    pass


class RShift(_ast.RShift, operator, AST):
    pass


class BitOr(_ast.BitOr, operator, AST):
    pass


class BitXor(_ast.BitXor, operator, AST):
    pass


class BitAnd(_ast.BitAnd, operator, AST):
    pass


class FloorDiv(_ast.FloorDiv, operator, AST):
    pass


class Invert(_ast.Invert, unaryop, AST):
    pass


class Not(_ast.Not, unaryop, AST):
    pass


class UAdd(_ast.UAdd, unaryop, AST):
    pass


class USub(_ast.USub, unaryop, AST):
    pass


class Eq(_ast.Eq, cmpop, AST):
    pass


class NotEq(_ast.NotEq, cmpop, AST):
    pass


class Lt(_ast.Lt, cmpop, AST):
    pass


class LtE(_ast.LtE, cmpop, AST):
    pass


class Gt(_ast.Gt, cmpop, AST):
    pass


class GtE(_ast.GtE, cmpop, AST):
    pass


class Is(_ast.Is, cmpop, AST):
    pass


class IsNot(_ast.IsNot, cmpop, AST):
    pass


class In(_ast.In, cmpop, AST):
    pass


class NotIn(_ast.NotIn, cmpop, AST):
    pass


class ExceptHandler(_ast.ExceptHandler, excepthandler, AST):
    type: None | expr
    name: None | str
    body: list[stmt]


class MatchValue(_ast.MatchValue, pattern, AST):
    value: expr


class MatchSingleton(_ast.MatchSingleton, pattern, AST):
    value: None | int


class MatchSequence(_ast.MatchSequence, pattern, AST):
    patterns: list[pattern]


class MatchMapping(_ast.MatchMapping, pattern, AST):
    keys: list[expr]
    patterns: list[pattern]
    rest: str


class MatchClass(_ast.MatchClass, pattern, AST):
    cls: expr
    patterns: list[pattern]
    kwd_attrs: list[str]
    kwd_patterns: list[pattern]


class MatchStar(_ast.MatchStar, pattern, AST):
    name: None | str


class MatchAs(_ast.MatchAs, pattern, AST):
    pattern: None
    name: None | str


class MatchOr(_ast.MatchOr, pattern, AST):
    patterns: list[pattern]


from .converter import parse  # noqa
