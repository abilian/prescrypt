import ast
import inspect

# language=Python
PREAMBLE = '''\
"""AUTOGENERATED FILE! DO NOT EDIT!

Custom AST.
"""
from __future__ import annotations
from typing import Any
import ast as _ast
from prescrypt.ast.mixin import Mixin


NodeVisitor = _ast.NodeVisitor
NodeTransformer = _ast.NodeTransformer
dump = _ast.dump
unparse = _ast.unparse

ellipsis = type(...)

'''

POSTAMBLE = """\
class Function(FunctionDef):
    _fields = ("name", "args", "body")


from .converter import parse  # noqa
"""

TYPES = {
    "AnnAssign.annotation": "expr",
    "AnnAssign.simple": "int",
    "AnnAssign.target": "expr",
    "AnnAssign.value": "None | expr",
    "Assert.msg": "None | expr",
    "Assert.test": "expr",
    "Assign.targets": "list[expr]",
    "Assign.type_comment": "None",
    "Assign.value": "expr",
    "AsyncFor.body": "list[stmt]",
    "AsyncFor.iter": "expr",
    "AsyncFor.orelse": "list[stmt]",
    "AsyncFor.target": "expr",
    "AsyncFor.type_comment": "None",
    "AsyncFunctionDef.args": "arguments",
    "AsyncFunctionDef.body": "list[stmt]",
    "AsyncFunctionDef.decorator_list": "list[expr]",
    "AsyncFunctionDef.name": "str",
    "AsyncFunctionDef.returns": "None | expr",
    "AsyncFunctionDef.type_comment": "None",
    "AsyncWith.body": "list[stmt]",
    "AsyncWith.items": "list[withitem]",
    "AsyncWith.type_comment": "None",
    "Attribute.attr": "str",
    "Attribute.ctx": "expr_context",
    "Attribute.value": "expr",
    "AugAssign.op": "operator",
    "AugAssign.target": "expr",
    "AugAssign.value": "expr",
    "Await.value": "expr",
    "BinOp.left": "expr",
    "BinOp.op": "operator",
    "BinOp.right": "expr",
    "BoolOp.op": "boolop",
    "BoolOp.values": "list[expr]",
    "Call.args": "list[expr]",
    "Call.func": "expr",
    "Call.keywords": "list[keyword]",
    "ClassDef.bases": "list[expr]",
    "ClassDef.body": "list[stmt]",
    "ClassDef.decorator_list": "list[expr]",
    "ClassDef.keywords": "list[keyword]",
    "ClassDef.name": "str",
    "Compare.comparators": "list[expr]",
    "Compare.left": "expr",
    "Compare.ops": "list[cmpop]",
    "Constant.kind": "None | str",
    "Constant.value": "None | bytes | complex | ellipsis | float | int | str",
    "Delete.targets": "list[expr]",
    "Dict.keys": "list[None] | list[expr]",
    "Dict.values": "list[expr]",
    "DictComp.generators": "list[comprehension]",
    "DictComp.key": "expr",
    "DictComp.value": "expr",
    "ExceptHandler.body": "list[stmt]",
    "ExceptHandler.name": "None | str",
    "ExceptHandler.type": "None | expr",
    "Expr.value": "expr",
    "For.body": "list[stmt]",
    "For.iter": "expr",
    "For.orelse": "list[stmt]",
    "For.target": "expr",
    "For.type_comment": "None",
    "FormattedValue.conversion": "int",
    "FormattedValue.format_spec": "None | expr",
    "FormattedValue.value": "expr",
    "FunctionDef.args": "arguments",
    "FunctionDef.body": "list[stmt]",
    "FunctionDef.decorator_list": "list[expr]",
    "FunctionDef.name": "str",
    "FunctionDef.returns": "None | expr",
    "FunctionDef.type_comment": "None",
    "GeneratorExp.elt": "expr",
    "GeneratorExp.generators": "list[comprehension]",
    "Global.names": "list[str]",
    "If.body": "list[stmt]",
    "If.orelse": "list[stmt]",
    "If.test": "expr",
    "IfExp.body": "expr",
    "IfExp.orelse": "expr",
    "IfExp.test": "expr",
    "Import.names": "list[alias]",
    "ImportFrom.level": "int",
    "ImportFrom.module": "None | str",
    "ImportFrom.names": "list[alias]",
    "JoinedStr.values": "list[expr]",
    "Lambda.args": "arguments",
    "Lambda.body": "expr",
    "List.ctx": "expr_context",
    "List.elts": "list[expr]",
    "ListComp.elt": "expr",
    "ListComp.generators": "list[comprehension]",
    "Match.cases": "list[match_case]",
    "Match.subject": "expr",
    "MatchAs.name": "None | str",
    "MatchAs.pattern": "None",
    "MatchClass.cls": "expr",
    "MatchClass.kwd_attrs": "list[str]",
    "MatchClass.kwd_patterns": "list[pattern]",
    "MatchClass.patterns": "list[pattern]",
    "MatchMapping.keys": "list[expr]",
    "MatchMapping.patterns": "list[pattern]",
    "MatchMapping.rest": "str",
    "MatchOr.patterns": "list[pattern]",
    "MatchSequence.patterns": "list[pattern]",
    "MatchSingleton.value": "None | int",
    "MatchStar.name": "None | str",
    "MatchValue.value": "expr",
    "Module.body": "list[stmt]",
    "Module.type_ignores": "Any",
    "Name.ctx": "expr_context",
    "Name.id": "str",
    "NamedExpr.target": "expr",
    "NamedExpr.value": "expr",
    "Nonlocal.names": "list[str]",
    "Raise.cause": "None | expr",
    "Raise.exc": "None | expr",
    "Return.value": "None | expr",
    "Set.elts": "list[expr]",
    "SetComp.elt": "expr",
    "SetComp.generators": "list[comprehension]",
    "Slice.lower": "None | expr",
    "Slice.step": "None | expr",
    "Slice.upper": "None | expr",
    "Starred.ctx": "expr_context",
    "Starred.value": "expr",
    "Subscript.ctx": "expr_context",
    "Subscript.slice": "expr",
    "Subscript.value": "expr",
    "Try.body": "list[stmt]",
    "Try.finalbody": "list[stmt]",
    "Try.handlers": "list[excepthandler]",
    "Try.orelse": "list[stmt]",
    "Tuple.ctx": "expr_context",
    "Tuple.elts": "list[expr]",
    "UnaryOp.op": "unaryop",
    "UnaryOp.operand": "expr",
    "While.body": "list[stmt]",
    "While.orelse": "list[stmt]",
    "While.test": "expr",
    "With.body": "list[stmt]",
    "With.items": "list[withitem]",
    "With.type_comment": "None",
    "Yield.value": "None | expr",
    "YieldFrom.value": "expr",
    "alias.asname": "None | str",
    "alias.name": "str",
    "arg.annotation": "None | expr",
    "arg.arg": "str",
    "arg.type_comment": "None",
    "arguments.args": "list[arg]",
    "arguments.defaults": "list[expr]",
    "arguments.kw_defaults": "list[None] | list[expr]",
    "arguments.kwarg": "None | arg",
    "arguments.kwonlyargs": "list[arg]",
    "arguments.posonlyargs": "list[arg]",
    "arguments.vararg": "None | arg",
    "comprehension.ifs": "list[expr]",
    "comprehension.is_async": "int",
    "comprehension.iter": "expr",
    "comprehension.target": "expr",
    "keyword.arg": "None | str",
    "keyword.value": "expr",
    "match_case.body": "list[stmt]",
    "match_case.guard": "None",
    "match_case.pattern": "pattern",
    "withitem.context_expr": "expr",
    "withitem.optional_vars": "None | expr",
}


def main():
    print(PREAMBLE)

    classes = []

    for obj in vars(ast).values():
        if not isinstance(obj, type):
            continue
        if not issubclass(obj, ast.AST):
            continue

        classes.append(obj)

    classes.sort(key=lambda x: len(inspect.getmro(x)))

    for cls in classes:
        cls_name = cls.__name__
        parents = get_parents(cls)
        parents_str = ", ".join(parents)

        print(f"class {cls_name}(_ast.{cls_name}, {parents_str}):")
        if cls._fields:
            for field in cls._fields:
                key = f"{cls_name}.{field}"
                field_type = TYPES.get(key, "Any")
                print(f"    {field}: {field_type}")
        else:
            print("    pass")
        print("\n")

    print(POSTAMBLE, end="")


def get_parents(cls):
    for parent in inspect.getmro(cls)[1:-1]:
        parent_name = parent.__name__

        if parent_name == "Constant":
            yield "Constant"

        if parent_name[0].islower():
            yield parent_name

    yield "Mixin"


if __name__ == "__main__":
    main()
